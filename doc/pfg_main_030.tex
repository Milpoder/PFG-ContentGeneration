\chapter[Diseño de Algoritmos]{\label{identificadorReferenciaCruzada}
Diseño de algoritmos}


Un motor de juego, es una herramienta software diseñada para asistir a los desarrolladores en la tarea de creación de juegos y aplicaciones gráficas\cite{B9}.

\section{Arquitectura:}

Un motor de juego está compuesto por una capa de tarjeta Hardware que representa el pc o consola sobre el que se ejecutará, una capa de drivers que son componentes Software que proporciona el sistema operativo o el proveedor de HArdware.

Por otra parte tiene el sistema operativo sobre el que está ejecutándose el juego todo el tiempo, la parte de SDKs que da soporte a la parte de programación del juego y la parte de estructuras de datos y algoritmos para dar soporte a la programación también.

Si nos centramos en la parte estética del juego, nos encontramos con una parte gráfica, una parte de animación de personajes y modelos y una parte de colisiones y física en la que se deforman los escenarios y da realismo al juego.

Sin embargo, si nos fijamos en la parte de la inteligencia artifical, nos encontramos una parte dedicada especialmente a eso, que está producida por el SDK.

Por último nos encontramos una serie de capas que ayudan a la depuración, renderizado, efectos visuales y gameplay para realizar pruebas.

En la \ref{Figura3} podemos ver como se organizan las distintas partes.

\begin{figure}[h!]

	\centering
	\includegraphics[width=8cm]{./eps/fig3.eps}
	\caption{Arquitectura de un motor de juegos, extraído de \cite{B10}}
	\label{Figura3}

\end{figure}
\newpage

\section{Selección de motor:}
Hay cientos de motores gráficos en el mercado y a la hora de elegir uno para el desarrollo de un proyecto hay que tener en cuenta los siguientes criterios\cite{B9}:

\begin{itemize}

	\item Si la herramienta tiene soporte o no para 2D y 3D.
	\item Si la herramienta es multiplataforma.
	\item Los lenguajes de programación que soporta la herramienta.
	\item Si tiene un motor de físicas y herramientas de inteligencia artificial.
	\item Si incorpora herramientas más avanzadas como editores de terrenos.
	\item El tipo de licencia que utiliza. 

\end{itemize}

En la tabla \ref{Tabla3} están los tres motores de juegos más importantes del mercado.

\begin{sidewaystable}[hbp]
\resizebox{20cm}{!}{ 
\begin{tabular}{| p{2cm} | p{1.5cm} | p{1.5cm} | p{2.5cm} | p{2cm} | p{2cm} | p{2cm} | p{4cm} | p{3.5cm}|}
	\hline 
		Nombre & 2D/3D & IDE & Lenguaje & Plataforma & Motor Físico & Herramientas de IA & Características Avanzadas & Licencia\\
   		\hline 
   		Unity3D & 2D y 3D & Mac y Windows & C\#, Boo, JS & Mac, Windows,
   		Linux, iOS, Android, PS3, XB360, PSP, Wii, PSVita, Flash,
   		Web & PhysX &  NavMesh y Path Finding & Forward y Deferred
   		rendering, Occlusion Culling, light mapping, light probing, LOD discreto, edición de terrenos, sistema de partículas & Comercial. Versión básica
   		gratuita (desktop y web) y versiones PRO y plataformas
   		móviles y consolas con un pago único sin royalties\\
   	\hline
    	UDK/Unreal Engine 4& 2D y 3D & Sí & Unreal Script & Mac, Windows,
    	iOS, Android, PS3, XB360, PSVita, Wii, Flash & PhysX &Path Finding &  Deferred rendering, occlusion culling, parallax mapping, Per Object Motion
    	Blur  &  Comercial. Versión libre y pago de royalties sobre producto vendido al superar un umbral de facturación. La versión Unreal Engine 3 dispone de más funcionalidades y una licencia comercial más cara.\\
    \hline
        Corona SDK & 2D & No & LUA & iOS, Android, Nook, Kindle Fire & Box2D & No. Deben ser programadas desde cero en LUA  & Interfaz simple de Lua para
        la programación de física & Comercial. Versión Indie para desarrollar para una única plataforma (iOS o Android) y versión Pro para todas las
        plataformas.\\
    \hline
\end{tabular}
}


\caption{Lista de Motores obtenida en el artículo: \cite{B9}} \label{Tabla3}
\end{sidewaystable}

Una vez que sabemos los criterios y los motores más usados del mercado, podemos disponernos a elegir un motor para nuestro proyecto.

Como el proyecto, tiene una parte en 2D, que es la de generación de planetas, necesitamos un motor que disponga de 2D, los cuales son los tres, sin embargo la parte de generación de ciudades, se hará en 3D, por lo que será necesario que disponga de 3D también,por lo que descartaremos el Corona SDK.

Por otra parte, necesitamos algo que se haga en PC, así que nos sirven los dos motores que nos quedan, pero si nos fijamos en los lenguajes de programación, Unity tiene una mayor variedad respecto a UDK que sólo soporta ''Unreal script''.

Si nos fijamos en la parte de motor de físicas, que es un motor que simula los movimientos físicos \cite{B11}, vemos que es una parte irrelevante, ya que no vamos a mover nada, ni vamos a generar movimientos sismicos, ni de personajes.

Por otra parte si nos fijamos en la parte de la inteligencia artificial, vemos que Unity tiene una mayor variedad que UDK, lo que para el proyecto nos beneficia bastante para la programación de los algoritmos genéticos, lo mismo que pasa con las características avanzadas.

Si nos fijamos en el punto de licencias, Unity cuenta con una versión gratuita para la plataforma de PC, lo que nos viene perfecto, sin embargo, UDK para ofrecernos lo mismo que Unity requiere de una subcripción.

Una vez estudiado todas las características que nos proporcionan los motores que más se usan en el mercado, podemos decir que Unity es el que más nos beneficiará para el desarrollo del proyecto.

\section{Selección de software de Modelado:}

Como de motor hemos seleccionado Unity, nos centramos en los programas de modelado que son compatible con Unity y vemos que existen los siguientes:

\begin{itemize}
	\item 3D Studio Max: este es un software bastante potente, acepta lenguajes de programación para generar algoritmos, pero con una licencia bastante cara, por lo que lo descartamos.
	\item Blender: software libre de modelado en 3D, es de los más utilizados, pero está capado en la geeración de algoritmos, por lo que no nos interesa.
	\item Autodesk Maya 3D: este es un software bastante completo, acepta su propio lenguaje de programación ''Mel'' pero también acepta algoritmos en Python, la licencia es bastante cara, pero al ser estudiante, Autodesk te regala una licencia de tres años, por lo que realizaremos los algoritmos para este software.
\end{itemize}

\section{Algoritmos:}

Con las herramientas mencionadas en los puntos anteriores, se han generado tres algoritmos que generan ciudades para la biblioteca, dos de ellos se han programado en Mel y otro en Python para comparar.

El primer algoritmo realizado en Mel y el tercero realizado en Python son muy similares, mientras que el segundo, realizado en MEl, es el algoritmo más complejo y al que dedicaremos más tiempo a su explicación.

\subsection{Primer algoritmo:}

Este algoritmo tiene una estructura bastante simple, está divido en tres partes, la primera comprueba si el GUI está creado y si no, crea uno nuevo donde leer los parámetros para generar las ciudades. La segunda parte es donde se genera la ciudad, en esta parte se utilizan los parámetros leídos anteriormente para recorrer una matriz e ir creando edificios aleatorios que se van reescalando para que todos tengan un mismo tamaño y la ciudad quede uniforme, por otro lado, la última parte realiza una limpieza de memoria para que no ocupe mucho espacio en memoria. En las figuras \ref{Figura4} y \ref{Figura5}, podemos ver la GUI de este algoritmo y una ejecución.

\begin{figure}[h] % indico que voy a poner una figura y [h] indica que la posición relativa, tambien puedo usar t = top entre otros.

\hfill
\begin{minipage}[t]{.45\textwidth}
\begin{center}
\epsfig{file=./eps/GUIprimera.eps, scale=0.4} % primera imagen colocada a la izquierda
\caption{Interfaz gráfica del primer algoritmo.}
\label{Figura4}
\end{center}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\begin{center}
\epsfig{file=./eps/primeralgoritmo.eps, scale=0.3} % segunda imagen colocada a la derecha 
\caption{Ejecución del primer algoritmo}
\label{Figura5}
\end{center}
\end{minipage}
\hfill
\end{figure}

\subsection{Segundo algoritmo:}

Este algoritmo es el más sofisticado y complejo, consta de los siguientes pasos:

\begin{itemize}
	\item En primer lugar comprobamos la versión de Autodesk Maya, ya que según la versión, utiliza unas aristas u otras.
	\item Tras el primer paso, comprobamos si no existe la ventana y si no existe, la crea, con dos botones que son princiales, en el primero genera la malla sobre la que se construirán los edificios, mientras que en la segunda se construyen los edificios.
	\item Para cada edificio, se genera un cuadrado principal, se separa aleatoriamente en plantas, siendo la distancia la misma en cada uno, se incluyen rectángulos para generar ventanas de forma seudo-aleatoria, se le coloca un cuadrado (o varios) en la parte superior y un cilindro con radio cero en uno de los extremos, se le inserta como antena si se ha seleccionado en el menú. Los edificios suelen ocupar un cuadrado de la malla, aunque si se desea se le puede cambiar el parámetro, para que todos tengan un tamaño parecido y no se quede estéticamente mal, se realiza como en los otros algoritmos un reescalado.
\end{itemize}

En las figuras \ref{Figura6} y \ref{Figura7} se muestra la interfaz y una ejecución realizada con el algoritmo.

\begin{figure}[h]

\hfill
\begin{minipage}[t]{.45\textwidth}
\begin{center}
\epsfig{file=./eps/GUIsegunda.eps, scale=0.3} % primera imagen colocada a la izquierda
\caption{Interfaz gráfica del segundo algoritmo.}
\label{Figura6}
\end{center}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\begin{center}
\epsfig{file=./eps/segundoalgoritmo.eps, scale=0.2} % segunda imagen colocada a la derecha 
\caption{Ejecución del segundo algoritmo}
\label{Figura7}
\end{center}
\end{minipage}
\hfill
\end{figure}

\subsection{Tercer algoritmo:}

Este algoritmo es parecido al primero, tiene una estructura similar aunque varía la forma de generar las ciudades, ya que en este caso los edificios son leídos de un fihcero y se van insertando en la matriz con un random, de manera que si se modifica el fichero,  cualquier persona podrá generar los edificios que vea necesarios en su juego, esto se puede realizar de una maenra bastante simple, mientras que en el primer algoritmo no ocurría eso. La primera y tercera parte si son iguales, dado que se comprueba si la GUI existe y en caso de que no exista se abre y se obtienen los valores introducidos de esta y en la tercera se limpia la memoria para eliminar temporales. En las figuras \ref{Figura8} y \ref{Figura9} podemos ver la GUI y una ejecución de este algoritmo.

\begin{figure}[h!]

	\centering
	\includegraphics[width=8cm]{./eps/GUItercera.eps}
	\caption{Interfaz gráfica del tercer algoritmo.}
	\label{Figura8}

\end{figure}

\begin{figure}[h!]

	\centering
	\includegraphics[width=8cm]{./eps/terceralgoritmo.eps}
	\caption{Ejecución del tercer algoritmo}
	\label{Figura9}

\end{figure}

\newpage

